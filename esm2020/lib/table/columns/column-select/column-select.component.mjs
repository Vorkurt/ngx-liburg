import { Component, EventEmitter, Input, Output, ViewEncapsulation, } from '@angular/core';
import { BaseColumn } from "../../base-column";
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "@angular/forms";
import * as i3 from "@angular/material/form-field";
import * as i4 from "@angular/material/table";
import * as i5 from "@angular/material/select";
import * as i6 from "@angular/material/core";
export class ColumnSelectComponent extends BaseColumn {
    constructor() {
        super(...arguments);
        this.truthy = false;
        this.onValueChanges = new EventEmitter();
    }
    ngOnInit() {
        if (this.options)
            this.options = this.options.sort();
        if (this.truthy) {
            this.options = [
                { index: 1, value: true, name: 'True' },
                { index: 0, value: false, name: 'False' },
            ];
        }
    }
    changeEntity(rowElement) {
        this.onValueChanges.emit(rowElement);
    }
}
ColumnSelectComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ColumnSelectComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
ColumnSelectComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: ColumnSelectComponent, selector: "elix-column-select", inputs: { options: "options", truthy: "truthy" }, outputs: { onValueChanges: "onValueChanges" }, providers: [{ provide: BaseColumn, useExisting: ColumnSelectComponent }], usesInheritance: true, ngImport: i0, template: "<ng-container [matColumnDef]=\"field\">\n  <mat-header-cell [class]=\"className\" mat-header-cell *matHeaderCellDef>\n    {{ name }}\n  </mat-header-cell>\n  <mat-cell [class]=\"className\" mat-cell *matCellDef=\"let element\">\n    <mat-form-field class=\"flex\" appearance=\"outline\">\n      {{ element.model[field].name }}\n      <mat-select\n        name=\"select\"\n        [(ngModel)]=\"element.model[field]\"\n        (ngModelChange)=\"element.model[field] = $event; changeEntity(element)\"\n      >\n        <mat-option *ngFor=\"let option of options\" [value]=\"option\">\n          {{ option.value }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </mat-cell>\n  <mat-footer-cell *matFooterCellDef>\n    {{footerMessage}}\n  </mat-footer-cell>\n</ng-container>\n", styles: [".mat-form-field-infix{display:flex!important}\n"], dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i3.MatFormField, selector: "mat-form-field", inputs: ["color", "appearance", "hideRequiredMarker", "hintLabel", "floatLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i4.MatHeaderCellDef, selector: "[matHeaderCellDef]" }, { kind: "directive", type: i4.MatColumnDef, selector: "[matColumnDef]", inputs: ["sticky", "matColumnDef"] }, { kind: "directive", type: i4.MatCellDef, selector: "[matCellDef]" }, { kind: "directive", type: i4.MatFooterCellDef, selector: "[matFooterCellDef]" }, { kind: "directive", type: i4.MatHeaderCell, selector: "mat-header-cell, th[mat-header-cell]" }, { kind: "directive", type: i4.MatCell, selector: "mat-cell, td[mat-cell]" }, { kind: "directive", type: i4.MatFooterCell, selector: "mat-footer-cell, td[mat-footer-cell]" }, { kind: "component", type: i5.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex"], exportAs: ["matSelect"] }, { kind: "component", type: i6.MatOption, selector: "mat-option", exportAs: ["matOption"] }], encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ColumnSelectComponent, decorators: [{
            type: Component,
            args: [{ selector: 'elix-column-select', providers: [{ provide: BaseColumn, useExisting: ColumnSelectComponent }], encapsulation: ViewEncapsulation.None, template: "<ng-container [matColumnDef]=\"field\">\n  <mat-header-cell [class]=\"className\" mat-header-cell *matHeaderCellDef>\n    {{ name }}\n  </mat-header-cell>\n  <mat-cell [class]=\"className\" mat-cell *matCellDef=\"let element\">\n    <mat-form-field class=\"flex\" appearance=\"outline\">\n      {{ element.model[field].name }}\n      <mat-select\n        name=\"select\"\n        [(ngModel)]=\"element.model[field]\"\n        (ngModelChange)=\"element.model[field] = $event; changeEntity(element)\"\n      >\n        <mat-option *ngFor=\"let option of options\" [value]=\"option\">\n          {{ option.value }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </mat-cell>\n  <mat-footer-cell *matFooterCellDef>\n    {{footerMessage}}\n  </mat-footer-cell>\n</ng-container>\n", styles: [".mat-form-field-infix{display:flex!important}\n"] }]
        }], propDecorators: { options: [{
                type: Input
            }], truthy: [{
                type: Input
            }], onValueChanges: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sdW1uLXNlbGVjdC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtbGlidXJnL3NyYy9saWIvdGFibGUvY29sdW1ucy9jb2x1bW4tc2VsZWN0L2NvbHVtbi1zZWxlY3QuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LWxpYnVyZy9zcmMvbGliL3RhYmxlL2NvbHVtbnMvY29sdW1uLXNlbGVjdC9jb2x1bW4tc2VsZWN0LmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsWUFBWSxFQUNaLEtBQUssRUFFTCxNQUFNLEVBQ04saUJBQWlCLEdBQ2xCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQzs7Ozs7Ozs7QUFrQjdDLE1BQU0sT0FBTyxxQkFBeUIsU0FBUSxVQUFVO0lBUHhEOztRQVlFLFdBQU0sR0FBWSxLQUFLLENBQUM7UUFFakIsbUJBQWMsR0FDbkIsSUFBSSxZQUFZLEVBQUUsQ0FBQztLQWV0QjtJQWJDLFFBQVE7UUFDTixJQUFJLElBQUksQ0FBQyxPQUFPO1lBQUUsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3JELElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNmLElBQUksQ0FBQyxPQUFPLEdBQUc7Z0JBQ2IsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRTtnQkFDdkMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRTthQUMxQyxDQUFDO1NBQ0g7SUFDSCxDQUFDO0lBRU0sWUFBWSxDQUFDLFVBQXNDO1FBQ3hELElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7O2tIQXRCVSxxQkFBcUI7c0dBQXJCLHFCQUFxQiw4SUFIckIsQ0FBQyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLHFCQUFxQixFQUFFLENBQUMsaURDdkIxRSw4eEJBc0JBOzJGRElhLHFCQUFxQjtrQkFQakMsU0FBUzsrQkFDRSxvQkFBb0IsYUFHbkIsQ0FBQyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsV0FBVyx1QkFBdUIsRUFBRSxDQUFDLGlCQUN6RCxpQkFBaUIsQ0FBQyxJQUFJOzhCQUlyQyxPQUFPO3NCQUROLEtBQUs7Z0JBSU4sTUFBTTtzQkFETCxLQUFLO2dCQUdDLGNBQWM7c0JBRHBCLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBWaWV3RW5jYXBzdWxhdGlvbixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Jhc2VDb2x1bW59IGZyb20gXCIuLi8uLi9iYXNlLWNvbHVtblwiO1xuaW1wb3J0IHtEYXRhU291cmNlTWF0ZXJpYWxUYWJsZX0gZnJvbSBcIi4uLy4uL3RhYmxlL3RhYmxlLmNvbXBvbmVudFwiO1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sdW1uU2VsZWN0PFQ+IHtcbiAgaW5kZXg6IG51bWJlcjtcbiAgdmFsdWU6IFQ7XG4gIG5hbWU6IHN0cmluZztcbn1cblxuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdlbGl4LWNvbHVtbi1zZWxlY3QnLFxuICB0ZW1wbGF0ZVVybDogJy4vY29sdW1uLXNlbGVjdC5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL2NvbHVtbi1zZWxlY3QuY29tcG9uZW50LnNjc3MnXSxcbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBCYXNlQ29sdW1uLCB1c2VFeGlzdGluZzogQ29sdW1uU2VsZWN0Q29tcG9uZW50IH1dLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxufSlcbmV4cG9ydCBjbGFzcyBDb2x1bW5TZWxlY3RDb21wb25lbnQ8VD4gZXh0ZW5kcyBCYXNlQ29sdW1uIGltcGxlbWVudHMgT25Jbml0IHtcbiAgQElucHV0KClcbiAgb3B0aW9ucz86IENvbHVtblNlbGVjdDxib29sZWFuPltdO1xuXG4gIEBJbnB1dCgpXG4gIHRydXRoeTogYm9vbGVhbiA9IGZhbHNlO1xuICBAT3V0cHV0KClcbiAgcHVibGljIG9uVmFsdWVDaGFuZ2VzOiBFdmVudEVtaXR0ZXI8RGF0YVNvdXJjZU1hdGVyaWFsVGFibGU8VD4+ID1cbiAgICBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMub3B0aW9ucykgdGhpcy5vcHRpb25zID0gdGhpcy5vcHRpb25zLnNvcnQoKTtcbiAgICBpZiAodGhpcy50cnV0aHkpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IFtcbiAgICAgICAgeyBpbmRleDogMSwgdmFsdWU6IHRydWUsIG5hbWU6ICdUcnVlJyB9LFxuICAgICAgICB7IGluZGV4OiAwLCB2YWx1ZTogZmFsc2UsIG5hbWU6ICdGYWxzZScgfSxcbiAgICAgIF07XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGNoYW5nZUVudGl0eShyb3dFbGVtZW50OiBEYXRhU291cmNlTWF0ZXJpYWxUYWJsZTxUPikge1xuICAgIHRoaXMub25WYWx1ZUNoYW5nZXMuZW1pdChyb3dFbGVtZW50KTtcbiAgfVxufVxuIiwiPG5nLWNvbnRhaW5lciBbbWF0Q29sdW1uRGVmXT1cImZpZWxkXCI+XG4gIDxtYXQtaGVhZGVyLWNlbGwgW2NsYXNzXT1cImNsYXNzTmFtZVwiIG1hdC1oZWFkZXItY2VsbCAqbWF0SGVhZGVyQ2VsbERlZj5cbiAgICB7eyBuYW1lIH19XG4gIDwvbWF0LWhlYWRlci1jZWxsPlxuICA8bWF0LWNlbGwgW2NsYXNzXT1cImNsYXNzTmFtZVwiIG1hdC1jZWxsICptYXRDZWxsRGVmPVwibGV0IGVsZW1lbnRcIj5cbiAgICA8bWF0LWZvcm0tZmllbGQgY2xhc3M9XCJmbGV4XCIgYXBwZWFyYW5jZT1cIm91dGxpbmVcIj5cbiAgICAgIHt7IGVsZW1lbnQubW9kZWxbZmllbGRdLm5hbWUgfX1cbiAgICAgIDxtYXQtc2VsZWN0XG4gICAgICAgIG5hbWU9XCJzZWxlY3RcIlxuICAgICAgICBbKG5nTW9kZWwpXT1cImVsZW1lbnQubW9kZWxbZmllbGRdXCJcbiAgICAgICAgKG5nTW9kZWxDaGFuZ2UpPVwiZWxlbWVudC5tb2RlbFtmaWVsZF0gPSAkZXZlbnQ7IGNoYW5nZUVudGl0eShlbGVtZW50KVwiXG4gICAgICA+XG4gICAgICAgIDxtYXQtb3B0aW9uICpuZ0Zvcj1cImxldCBvcHRpb24gb2Ygb3B0aW9uc1wiIFt2YWx1ZV09XCJvcHRpb25cIj5cbiAgICAgICAgICB7eyBvcHRpb24udmFsdWUgfX1cbiAgICAgICAgPC9tYXQtb3B0aW9uPlxuICAgICAgPC9tYXQtc2VsZWN0PlxuICAgIDwvbWF0LWZvcm0tZmllbGQ+XG4gIDwvbWF0LWNlbGw+XG4gIDxtYXQtZm9vdGVyLWNlbGwgKm1hdEZvb3RlckNlbGxEZWY+XG4gICAge3tmb290ZXJNZXNzYWdlfX1cbiAgPC9tYXQtZm9vdGVyLWNlbGw+XG48L25nLWNvbnRhaW5lcj5cbiJdfQ==